{"version":3,"file":"index.cjs","sources":["../src/asTree.ts","../src/asText.ts","../src/serialize.ts","../src/types.ts","../src/wrapMapSerializer.ts","../src/composeSerializers.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (\n\t\t\t\tsiblingSpan !== span &&\n\t\t\t\tsiblingSpan.start >= span.start &&\n\t\t\t\tsiblingSpan.end <= span.end\n\t\t\t) {\n\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n","import { RichTextField, RTTextNode } from \"@prismicio/types\";\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\";\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text;\n\t\t}\n\t}\n\n\treturn result;\n};\n","import { RichTextField } from \"@prismicio/types\";\nimport { RichTextFunctionSerializer, TreeNode } from \"./types\";\nimport { asTree } from \"./asTree\";\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the serializer\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t);\n};\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = [];\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i];\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t);\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode);\n\t\t}\n\t}\n\n\treturn serializedTreeNodes;\n};\n","import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTEmbedNode,\n\tRTEmNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n} from \"@prismicio/types\";\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType],\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined;\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"];\n\tnode: Node;\n\ttext: TextType;\n\tchildren: ReturnType[];\n\tkey: string;\n}) => ReturnType | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n * @typeParam ReturnType - Return type of the map serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>;\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>;\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>;\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>;\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>;\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>;\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>;\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>;\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>;\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>;\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>;\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>;\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>;\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>;\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>;\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>;\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>;\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>;\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>;\n};\n\n// Tree\nexport interface Tree {\n\tkey: string;\n\tchildren: TreeNode[];\n}\n\nexport interface TreeNode {\n\tkey: string;\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType];\n\ttext?: string;\n\tnode: RTAnyNode;\n\tchildren: TreeNode[];\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const;\n","import {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextReversedNodeType,\n} from \"./types\";\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the map serializer\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t];\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t});\n\t\t}\n\t};\n};\n","import { RichTextFunctionSerializer } from \"./types\";\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of serializers\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i];\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n"],"names":["RichTextNodeType"],"mappings":"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"}